<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NZ Property Value Finder</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/styles/main.css">
    <meta name="description" content="Quickly find New Zealand property values and insights from Homes.co.nz, OneRoof, QV, RealEstate.co.nz, TradeMe, and PropertyValue.co.nz. Get estimated values, sales history, and more.">
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0910314329433856"
          crossorigin="anonymous"></script>
</head>
<body>
    <header class="site-header">
        <div class="header-content-wrapper">
            <h1 class="header-title">Find Your Property Values</h1>
            <div class="header-search-wrapper">
                <input type="text" id="addressInput" placeholder="Enter an address..." class="flex-grow py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="searchButton" class="font-semibold focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <span class="long-text">Find property values</span>
                    <span class="short-text">Find</span>
                </button>
            </div>
        </div>
    </header>

    <div class="xx">
        <div id="introductoryText" class="container">
            <p class="mb-2"><strong>Unlock comprehensive property insights across New Zealand.</strong></p>
            <p class="mb-2">Simply enter any New Zealand address to instantly access estimated property values, recent sales data, and market trends from the leading property websites including Homes.co.nz, OneRoof, QV, RealEstate.co.nz, TradeMe Property Insights, and PropertyValue.co.nz.</p>
            <p>Whether you're buying, selling, or just curious, get all the information you need in one convenient place to make informed decisions about property in NZ.</p>
        </div>

        <div class="loading-spinner" id="loadingSpinner"></div>
        <p class="error-message" id="errorMessage"></p>

        <div id="summaryData" class="container">
            <div id="summaryPhotoWrapper"></div>
            <div id="summaryTextContent"></div>
        </div>

        <div id="results">
            <div class="container">
            <h2 class="mt-8">Estimated Values:</h2>
            <div class="overflow-x-auto">
                <table id="estimatedValuesTable" class="min-w-full bg-white border border-gray-200">
                    <thead>
                        <tr class="bg-gray-100 text-left text-sm text-gray-600 uppercase tracking-wider">
                            <th class="py-3 px-4 border-b border-gray-200">Source</th>
                            <th class="py-3 px-4 border-b border-gray-200">Low</th>
                            <th class="py-3 px-4 border-b border-gray-200">Medium</th>
                            <th class="py-3 px-4 border-b border-gray-200">High</th>
                        </tr>
                    </thead>
                    <tbody id="estimatedValuesTableBody">
                    </tbody>
                </table>
            </div>
            <div id="estimatedValuesSummary" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg flex justify-between items-center text-gray-800">
            </div></div>
            <div class="container">
                <h2>Property Page Links</h2>
            <ul id="urlList">
            </ul>
               </div>  
        </div>
    </div>

    <div class="disclaimer-text">
        Disclaimer: While we've done our best to correctly find property pages for an address, it may not be exact. Please review property links for accuracy. Some addresses will not be matched exactly because of unit numbers etc.
    </div>

    <script>
        let autocomplete;

        function initAutocomplete() {
            const addressInput = document.getElementById('addressInput');
            if (addressInput) {
                autocomplete = new google.maps.places.Autocomplete(addressInput, {
                    types: ['address'],
                    componentRestrictions: { 'country': ['nz'] }
                });
                autocomplete.addListener('place_changed', onPlaceChanged);
            } else {
                console.error("Address input element not found. Autocomplete could not be initialized.");
            }
        }

        function onPlaceChanged() {
            const place = autocomplete.getPlace();
            const addressInput = document.getElementById('addressInput');
            const errorMessage = document.getElementById('errorMessage');

            if (!place || !place.address_components || !place.geometry) {
                console.warn("No valid place details available for input: '" + (place && place.name ? place.name : addressInput.value) + "'");
                return;
            }

            let subpremise = '';
            let streetNumber = '';
            let route = '';
            let currentSublocality = '';
            let currentLocality = '';

            for (let i = 0; i < place.address_components.length; i++) {
                const component = place.address_components[i];
                const types = component.types; 

                if (types.includes('subpremise')) {
                    subpremise = component.long_name;
                } else if (types.includes('street_number')) {
                    streetNumber = component.long_name;
                } else if (types.includes('route')) {
                    route = component.long_name;
                } else if (types.includes('sublocality_level_1') || types.includes('sublocality')) {
                    currentSublocality = component.long_name; 
                } else if (types.includes('locality')) {
                    currentLocality = component.long_name;
                }
            }
            
            let addressParts = [];
            let streetAddressPart = '';

            if (route) { 
                if (subpremise && streetNumber) {
                    streetAddressPart = `${subpremise}/${streetNumber} ${route}`;
                } else if (streetNumber) {
                    streetAddressPart = `${streetNumber} ${route}`;
                } else if (subpremise) {
                    streetAddressPart = `${subpremise} ${route}`;
                } else { 
                    streetAddressPart = route;
                }
                addressParts.push(streetAddressPart);
            }

            if (currentSublocality) {
                addressParts.push(currentSublocality);
            } else if (currentLocality && streetAddressPart) { 
                addressParts.push(currentLocality);
            }

            const desiredAddress = addressParts.join(', ');

            if (desiredAddress) {
                addressInput.value = desiredAddress;
                if (errorMessage) errorMessage.textContent = '';
            } else {
                let fallbackValue = place.formatted_address || place.name || "";
                addressInput.value = fallbackValue;
                if (errorMessage) {
                    if (fallbackValue) {
                        errorMessage.textContent = "Could not parse specific address components, using full address.";
                    } else {
                        errorMessage.textContent = "Address details could not be retrieved.";
                    }
                }
                console.warn("Failed to parse desired address components. Using fallback:", fallbackValue);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const addressInput = document.getElementById('addressInput');
            const searchButton = document.getElementById('searchButton');
            const urlList = document.getElementById('urlList');
            const errorMessage = document.getElementById('errorMessage');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const summaryDataContainer = document.getElementById('summaryData');
            const summaryPhotoWrapper = document.getElementById('summaryPhotoWrapper');
            const summaryTextContent = document.getElementById('summaryTextContent');
            const resultsSection = document.getElementById('results');
            const estimatedValuesTableBody = document.getElementById('estimatedValuesTableBody');
            const estimatedValuesSummary = document.getElementById('estimatedValuesSummary');
            const introductoryText = document.getElementById('introductoryText');

            function parseCurrencyToNumber(currencyString) {
                if (!currencyString || typeof currencyString !== 'string') {
                    return NaN;
                }
                let cleanedString = currencyString.replace(/[\$,]/g, '').trim();
                let numericValue = parseFloat(cleanedString);
                if (cleanedString.endsWith('M')) {
                    numericValue *= 1000000;
                } else if (cleanedString.endsWith('K')) {
                    numericValue *= 1000;
                }
                return numericValue;
            }

            async function loadGoogleMapsScript() {
                try {
                    const response = await fetch('/api/get-google-maps-key');
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Failed to fetch API key: ${response.statusText}`);
                    }
                    const data = await response.json();
                    const googleMapsApiKey = data.apiKey;

                    if (!googleMapsApiKey) {
                        throw new Error('API key not returned by server.');
                    }

                    const googleMapsScript = document.createElement('script');
                    googleMapsScript.src = `https://maps.googleapis.com/maps/api/js?key=${googleMapsApiKey}&libraries=places&callback=initAutocomplete`;
                    googleMapsScript.async = true;
                    googleMapsScript.defer = true; 
                    document.head.appendChild(googleMapsScript);

                } catch (error) {
                    console.error("Error loading Google Maps API script:", error);
                    if(errorMessage) errorMessage.textContent = "Error initializing maps: " + error.message;
                    if (addressInput) addressInput.disabled = true;
                    if (searchButton) searchButton.disabled = true;
                }
            }
            
            loadGoogleMapsScript();

            function addLinkToUI(siteName, urlOrError, isError = false, scrapedData = null) {
                const listItem = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'site-name';
                nameSpan.textContent = siteName;
                listItem.appendChild(nameSpan);

                if (isError) {
                    const textSpan = document.createElement('span');
                    textSpan.className = 'no-link';
                    textSpan.classList.add('error-text-small'); 
                    textSpan.textContent = urlOrError;
                    listItem.appendChild(textSpan);
                } else {
                    const link = document.createElement('a');
                    link.href = urlOrError;
                    link.textContent = urlOrError;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    listItem.appendChild(link);

                    if (scrapedData && Object.keys(scrapedData).length > 0 && !scrapedData.estimatedValues) {
                        const dataDiv = document.createElement('div');
                        dataDiv.className = 'scraped-data';
                        let dataText = '';
                        dataDiv.innerHTML = dataText.trim().replace(/\n/g, '<br>');
                        if (dataText.trim()) {
                            listItem.appendChild(dataDiv);
                        }
                    }
                }
                urlList.appendChild(listItem);
            }

            let lowValuesForBolding = [];
            let highValuesForBolding = [];

            function displayEstimatedValues(siteName, url, estimatedValues, urlError = null) {
                const row = estimatedValuesTableBody.insertRow();
                row.className = 'text-sm text-gray-800';

                const websiteCell = row.insertCell();
                if (url && url !== 'N/A' && url !== 'No direct link found.' && !url.includes("Error")) {
                    const link = document.createElement('a');
                    link.href = url;
                    link.textContent = siteName;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.className = 'text-blue-700 hover:underline font-medium';
                    websiteCell.appendChild(link);

                    if (urlError) {
                        const errorSpan = document.createElement('span');
                        errorSpan.classList.add('error-text-small'); 
                        errorSpan.textContent = ` (${urlError})`;
                        websiteCell.appendChild(errorSpan);
                    }

                } else {
                    websiteCell.textContent = siteName;
                    if (urlError) {
                        const errorSpan = document.createElement('span');
                        errorSpan.classList.add('error-text-small'); 
                        errorSpan.textContent = ` (${urlError})`;
                        websiteCell.appendChild(errorSpan);
                    } else if (url && url.includes("Error")) {
                        const errorSpan = document.createElement('span');
                        errorSpan.classList.add('error-text-small'); 
                        errorSpan.textContent = ` (Error retrieving URL)`;
                        websiteCell.appendChild(errorSpan);
                    }
                }
                websiteCell.className += ' py-2 px-4 border-b border-gray-200';

                const lowCell = row.insertCell();
                const lowValue = estimatedValues.low || 'N/A';
                lowCell.textContent = lowValue;
                lowCell.className = 'py-2 px-4 border-b border-gray-200';
                const numericLow = parseCurrencyToNumber(lowValue);
                if (!isNaN(numericLow)) {
                    lowValuesForBolding.push({ value: numericLow, cell: lowCell });
                }

                const mediumCell = row.insertCell();
                mediumCell.textContent = estimatedValues.medium || 'N/A';
                mediumCell.className = 'py-2 px-4 border-b border-gray-200';

                const highCell = row.insertCell();
                const highValue = estimatedValues.high || 'N/A';
                highCell.textContent = highValue;
                highCell.className = 'py-2 px-4 border-b border-gray-200';
                const numericHigh = parseCurrencyToNumber(highValue);
                if (!isNaN(numericHigh)) {
                    highValuesForBolding.push({ value: numericHigh, cell: highCell });
                }
            }

            function highlightMinMaxValues() {
                if (lowValuesForBolding.length > 0) {
                    const minLowValue = Math.min(...lowValuesForBolding.map(item => item.value));
                    lowValuesForBolding.forEach(item => {
                        if (item.value === minLowValue) {
                            item.cell.classList.add('bold-value');
                        }
                    });
                }
                if (highValuesForBolding.length > 0) {
                    const maxHighValue = Math.max(...highValuesForBolding.map(item => item.value));
                    highValuesForBolding.forEach(item => {
                        if (item.value === maxHighValue) {
                            item.cell.classList.add('bold-value');
                        }
                    });
                }
            }

            searchButton.addEventListener('click', async () => {
                const address = addressInput.value.trim();
                if (!address) {
                    errorMessage.textContent = 'Please enter an address.';
                    return;
                }

                errorMessage.textContent = '';
                urlList.innerHTML = ''; // Clear previous results
                estimatedValuesTableBody.innerHTML = ''; // Clear previous estimated values
                estimatedValuesSummary.innerHTML = ''; // Clear summary
                summaryDataContainer.style.display = 'none'; // Hide photo/text summary
                resultsSection.style.display = 'none'; // Hide results section
                introductoryText.style.display = 'none'; // Hide introductory text
                loadingSpinner.style.display = 'block';
                searchButton.disabled = true;

                lowValuesForBolding = [];
                highValuesForBolding = [];

                let anyLinkGenerated = false;
                let mediumValues = [];
                let pvDataFound = false;

                const apiEndpoints = [
                    { name: 'Homes.co.nz', url: '/api/get-homes-url', scrapeValuesUrl: '/api/scrape-homes-values' },
                    { name: 'OneRoof.co.nz', url: '/api/get-oneroof-url', scrapeValuesUrl: '/api/scrape-oneroof-values' },
                    { name: 'QV.co.nz', url: '/api/get-qv-url', scrapeValuesUrl: '/api/scrape-qv-values' },
                    { name: 'RealEstate.co.nz', url: '/api/get-realestate-url', scrapeValuesUrl: null },
                    { name: 'TradeMe', url: '/api/get-trademe-url', scrapeValuesUrl: null }, // Re-enabled TradeMe
                    { name: 'PropertyValue.co.nz', url: '/api/get-propertyvalue-url', scrapeValuesUrl: null, scrapeData: true }
                ];

                const fetchPromises = apiEndpoints.map(async (endpoint) => {
                    let siteUrl = 'N/A';
                    let estimatedValues = { low: 'N/A', medium: 'N/A', high: 'N/A' };
                    let urlError = null;
                    let scrapedData = null;

                    try {
                        const response = await fetch(endpoint.url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ address })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            siteUrl = data.url;
                            anyLinkGenerated = true;

                            if (endpoint.scrapeValuesUrl) {
                                try {
                                    const scrapeResponse = await fetch(endpoint.scrapeValuesUrl, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ url: siteUrl })
                                    });
                                    const scrapeData = await scrapeResponse.json();
                                    if (scrapeResponse.ok && scrapeData.estimatedValues) {
                                        estimatedValues = scrapeData.estimatedValues;
                                    } else {
                                        console.warn(`Failed to scrape values for ${endpoint.name}:`, scrapeData.error || scrapeResponse.statusText);
                                    }
                                } catch (scrapeError) {
                                    console.error(`Error scraping values for ${endpoint.name}:`, scrapeError);
                                }
                            } else if (endpoint.scrapeData && data.data) {
                                scrapedData = data.data;
                                if (scrapedData.estimatedValues) {
                                    estimatedValues = scrapedData.estimatedValues;
                                }
                            }
                        } else {
                            urlError = data.error || `Error: ${response.statusText}`;
                        }
                    } catch (error) {
                        urlError = `Network error: ${error.message}`;
                        console.error(`Error fetching URL for ${endpoint.name}:`, error);
                    }

                    if (siteUrl !== 'N/A' || urlError) {
                        addLinkToUI(endpoint.name, siteUrl, siteUrl === 'N/A' || urlError !== null, scrapedData);
                    }
                    
                    if (estimatedValues.medium !== 'N/A' && !isNaN(parseCurrencyToNumber(estimatedValues.medium))) {
                        mediumValues.push(parseCurrencyToNumber(estimatedValues.medium));
                    }

                    return { endpointName: endpoint.name, estimatedValues, scrapedData };
                });

                try {
                    const results = await Promise.allSettled(fetchPromises);

                    results.forEach(result => {
                        if (result.status === 'fulfilled') {
                            const { endpointName, estimatedValues, scrapedData } = result.value;
                            if (estimatedValues.low !== 'N/A' || estimatedValues.medium !== 'N/A' || estimatedValues.high !== 'N/A') {
                                displayEstimatedValues(endpointName, scrapedData?.url || 'N/A', estimatedValues, scrapedData?.urlError);
                            }
                            if (scrapedData && endpointName === 'PropertyValue.co.nz') {
                                pvDataFound = true;
                                let summaryText = ``;
                                if (scrapedData.lastSold && scrapedData.lastSold !== 'N/A') {
                                    summaryText += `Last Sold: ${scrapedData.lastSold}\n`;
                                }
                                if (scrapedData.capitalValue && scrapedData.capitalValue !== 'N/A') {
                                    summaryText += `Capital Value: ${scrapedData.capitalValue}\n`;
                                }
                                if (scrapedData.landValue && scrapedData.landValue !== 'N/A') {
                                    summaryText += `Land Value: ${scrapedData.landValue}\n`;
                                }
                                if (scrapedData.improvementValue && scrapedData.improvementValue !== 'N/A') {
                                    summaryText += `Improvement Value: ${scrapedData.improvementValue}\n`;
                                }
                                if (scrapedData.valuationDate && scrapedData.valuationDate !== 'N/A') {
                                    summaryText += `Valuation Date: ${scrapedData.valuationDate}\n`;
                                }

                                if (scrapedData.propertyPhotoSrc && scrapedData.propertyPhotoSrc !== 'N/A' && scrapedData.propertyPhotoSrc !== 'Not Found on Page') {
                                    summaryPhotoWrapper.innerHTML = `<img src="${scrapedData.propertyPhotoSrc}" alt="Property Photo" class="w-full h-auto rounded-lg shadow-md">`;
                                    summaryPhotoWrapper.style.display = 'block';
                                } else {
                                    summaryPhotoWrapper.innerHTML = '';
                                    summaryPhotoWrapper.style.display = 'none';
                                }
                                summaryTextContent.innerHTML = summaryText.trim().replace(/\n/g, '<br>');
                                summaryTextContent.style.display = 'block';
                            }
                        } else {
                            console.error(`Promise rejected for an endpoint:`, result.reason);
                            // Optionally add an error message to the UI for the failed endpoint
                        }
                    });

                    highlightMinMaxValues(); // Call this after all values are displayed

                    if (mediumValues.length > 0) {
                        const averageEstimatedValue = mediumValues.reduce((a, b) => a + b, 0) / mediumValues.length;
                        let lastSoldPrice = null; // Assume PropertyValue.co.nz data has lastSold in format "$X,XXX,XXX on YYYY-MM-DD"
                        if (pvDataFound && results.find(r => r.value?.endpointName === 'PropertyValue.co.nz')?.value?.scrapedData?.lastSold !== 'N/A') {
                            const pvScrapedData = results.find(r => r.value?.endpointName === 'PropertyValue.co.nz').value.scrapedData;
                            const lastSoldString = pvScrapedData.lastSold;
                            const match = lastSoldString.match(/\$([\d,.]+)/);
                            if (match) {
                                lastSoldPrice = parseCurrencyToNumber(match[0]);
                            }
                        }

                        let rateOfReturnHtml = '';
                        if (lastSoldPrice && !isNaN(lastSoldPrice) && lastSoldPrice > 0) {
                            const annualReturn = ((averageEstimatedValue - lastSoldPrice) / lastSoldPrice) * 100;
                            const rateOfReturnClass = annualReturn >= 0 ? 'text-green-700' : 'text-red-700';
                            rateOfReturnHtml = `
                                <span class="font-bold">Annual Return:</span>
                                <span class="text-lg font-bold ${rateOfReturnClass} ml-2">
                                    ${annualReturn.toFixed(2)}%
                                </span>
                            `;
                        }
                        
                        const averageEstimatedValueHtml = abbreviateNumber(averageEstimatedValue);

                        const summaryContentHtml = `
                            <div class="flex-1 text-center">
                                <span class="font-bold">Average Estimated Value:</span>
                                <span class="text-lg font-bold text-green-700 ml-2">
                                    ${averageEstimatedValueHtml}
                                </span>
                            </div>
                            <div class="flex-1 text-center">
                                ${rateOfReturnHtml}
                            </div>
                        `;

                        estimatedValuesSummary.innerHTML = summaryContentHtml;
                        estimatedValuesSummary.style.display = 'flex';
                    }

                    if (pvDataFound) {
                        summaryDataContainer.style.display = 'flex';
                    }

                    if (anyLinkGenerated || mediumValues.length > 0 || pvDataFound) { 
                        resultsSection.style.display = 'block';
                    }

                    if (!anyLinkGenerated && !pvDataFound && mediumValues.length === 0) {
                        errorMessage.textContent = 'No property links, summary data, or estimated values could be generated for the given address from any site.';
                         introductoryText.style.display = 'block'; 
                    }

                } catch (error) {
                    console.error('Overall error during link generation:', error);
                    errorMessage.textContent = error.message || 'An unexpected overall error occurred during link generation.';
                     introductoryText.style.display = 'block'; 
                } finally {
                    loadingSpinner.style.display = 'none';
                    searchButton.disabled = false;
                }
            });
        });

        // Helper function for number abbreviation (if not already defined elsewhere)
        function abbreviateNumber(value) {
            let newValue = value;
            const suffixes = ["", "K", "M", "B", "T"];
            let suffixNum = 0;
            while (newValue >= 1000 && suffixNum < suffixes.length - 1) {
                newValue /= 1000;
                suffixNum++;
            }
            return "$" + newValue.toFixed(2) + suffixes[suffixNum];
        }
    </script>
</body>
</html>
