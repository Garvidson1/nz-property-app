<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NZ Property Value Finder</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/styles/main.css">
    <meta name="description" content="Quickly find New Zealand property values and insights from Homes.co.nz, OneRoof, QV, RealEstate.co.nz, TradeMe, and PropertyValue.co.nz. Get estimated values, sales history, and more.">
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0910314329433856"
          crossorigin="anonymous"></script>
</head>
<body>
    <header class="site-header">
        <div class="header-content-wrapper">
            <h1 class="header-title">Find Your Property Values</h1>
            <div class="header-search-wrapper">
                <input type="text" id="addressInput" placeholder="Enter an address..." class="flex-grow py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="searchButton" class="font-semibold focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <span class="long-text">Find property values</span>
                    <span class="short-text">Find</span>
                </button>
            </div>
        </div>
    </header>

    <div class="xx">
        <div id="introductoryText" class="container">
            <p class="mb-2"><strong>Unlock comprehensive property insights across New Zealand.</strong></p>
            <p class="mb-2">Simply enter any New Zealand address to instantly access estimated property values, recent sales data, and market trends from the leading property websites including Homes.co.nz, OneRoof, QV, RealEstate.co.nz, TradeMe Property Insights, and PropertyValue.co.nz.</p>
            <p>Whether you're buying, selling, or just curious, get all the information you need in one convenient place to make informed decisions about property in NZ.</p>
        </div>

        <div class="loading-spinner" id="loadingSpinner"></div>
        <p class="error-message" id="errorMessage"></p>

        <div id="summaryData" class="container">
            <div id="summaryPhotoWrapper"></div>
            <div id="summaryTextContent"></div>
        </div>

        <div id="results">
            <div class="container">
            <h2 class="mt-8">Estimated Values:</h2>
            <div id="overallSummaryText" class="mb-4 p-4 bg-gray-50 border border-gray-200 rounded-lg text-gray-700 hidden">
                </div>
            <div class="overflow-x-auto">
                <table id="estimatedValuesTable" class="min-w-full bg-white border border-gray-200">
                    <thead>
                        <tr class="bg-gray-100 text-left text-sm text-gray-600 uppercase tracking-wider">
                            <th class="py-3 px-4 border-b border-gray-200">Source</th>
                            <th class="py-3 px-4 border-b border-gray-200">Low</th>
                            <th class="py-3 px-4 border-b border-gray-200">Medium</th>
                            <th class="py-3 px-4 border-b border-gray-200">High</th>
                        </tr>
                    </thead>
                    <tbody id="estimatedValuesTableBody">
                    </tbody>
                </table>
            </div>
            <div id="estimatedValuesSummary" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg flex justify-between items-center text-gray-800">
            </div></div>
            <div class="container">
                <h2>Property Page Links</h2>
            <ul id="urlList">
            </ul>
               </div>  
        </div>
    </div>

    <div class="disclaimer-text">
        Disclaimer: While we've done our best to correctly find property pages for an address, it may not be exact. Please review property links for accuracy. Some addresses will not be matched exactly because of unit numbers etc.
    </div>

    <script>
        let autocomplete;

        function initAutocomplete() {
            const addressInput = document.getElementById('addressInput');
            if (addressInput) {
                autocomplete = new google.maps.places.Autocomplete(addressInput, {
                    types: ['address'],
                    componentRestrictions: { 'country': ['nz'] }
                });
                autocomplete.addListener('place_changed', onPlaceChanged);
            } else {
                console.error("Address input element not found. Autocomplete could not be initialized.");
            }
        }

        function onPlaceChanged() {
            const place = autocomplete.getPlace();
            const addressInput = document.getElementById('addressInput');
            const errorMessage = document.getElementById('errorMessage');

            if (!place || !place.address_components || !place.geometry) {
                console.warn("No valid place details available for input: '" + (place && place.name ? place.name : addressInput.value) + "'");
                return;
            }

            let subpremise = '';
            let streetNumber = '';
            let route = '';
            let currentSublocality = '';
            let currentLocality = '';

            for (let i = 0; i < place.address_components.length; i++) {
                const component = place.address_components[i];
                const types = component.types; 

                if (types.includes('subpremise')) {
                    subpremise = component.long_name;
                } else if (types.includes('street_number')) {
                    streetNumber = component.long_name;
                } else if (types.includes('route')) {
                    route = component.long_name;
                } else if (types.includes('sublocality_level_1') || types.includes('sublocality')) {
                    currentSublocality = component.long_name; 
                } else if (types.includes('locality')) {
                    currentLocality = component.long_name;
                }
            }
            
            let addressParts = [];
            let streetAddressPart = '';

            if (route) { 
                if (subpremise && streetNumber) {
                    streetAddressPart = `${subpremise}/${streetNumber} ${route}`;
                } else if (streetNumber) {
                    streetAddressPart = `${streetNumber} ${route}`;
                } else if (subpremise) {
                    streetAddressPart = `${subpremise} ${route}`;
                } else { 
                    streetAddressPart = route;
                }
                addressParts.push(streetAddressPart);
            }

            if (currentSublocality) {
                addressParts.push(currentSublocality);
            } else if (currentLocality && streetAddressPart) { 
                addressParts.push(currentLocality);
            }

            const desiredAddress = addressParts.join(', ');

            if (desiredAddress) {
                addressInput.value = desiredAddress;
                if (errorMessage) errorMessage.textContent = '';
            } else {
                let fallbackValue = place.formatted_address || place.name || "";
                addressInput.value = fallbackValue;
                if (errorMessage) {
                    if (fallbackValue) {
                        errorMessage.textContent = "Could not parse specific address components, using full address.";
                    } else {
                        errorMessage.textContent = "Address details could not be retrieved.";
                    }
                }
                console.warn("Failed to parse desired address components. Using fallback:", fallbackValue);
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const addressInput = document.getElementById('addressInput');
            const searchButton = document.getElementById('searchButton');
            const urlList = document.getElementById('urlList');
            const errorMessage = document.getElementById('errorMessage');
            const loadingSpinner = document.getElementById('loadingSpinner');
            const summaryDataContainer = document.getElementById('summaryData');
            const summaryPhotoWrapper = document.getElementById('summaryPhotoWrapper');
            const summaryTextContent = document.getElementById('summaryTextContent');
            const resultsSection = document.getElementById('results');
            const estimatedValuesTableBody = document.getElementById('estimatedValuesTableBody');
            const estimatedValuesSummary = document.getElementById('estimatedValuesSummary');
            const introductoryText = document.getElementById('introductoryText');
            const overallSummaryTextElement = document.getElementById('overallSummaryText'); // NEW LINE

            function parseCurrencyToNumber(currencyString) {
                if (!currencyString || typeof currencyString !== 'string') {
                    return NaN;
                }
                let cleanedString = currencyString.replace(/[\$,]/g, '').trim();
                let numericValue = parseFloat(cleanedString);
                if (cleanedString.endsWith('M')) {
                    numericValue *= 1000000;
                } else if (cleanedString.endsWith('K')) {
                    numericValue *= 1000;
                }
                return numericValue;
            }

            async function loadGoogleMapsScript() {
                try {
                    const response = await fetch('/api/get-google-maps-key');
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `Failed to fetch API key: ${response.statusText}`);
                    }
                    const data = await response.json();
                    const googleMapsApiKey = data.apiKey;

                    if (!googleMapsApiKey) {
                        throw new Error('API key not returned by server.');
                    }

                    const googleMapsScript = document.createElement('script');
                    googleMapsScript.src = `https://maps.googleapis.com/maps/api/js?key=${googleMapsApiKey}&libraries=places&callback=initAutocomplete`;
                    googleMapsScript.async = true;
                    googleMapsScript.defer = true; 
                    document.head.appendChild(googleMapsScript);

                } catch (error) {
                    console.error("Error loading Google Maps API script:", error);
                    if(errorMessage) errorMessage.textContent = "Error initializing maps: " + error.message;
                    if (addressInput) addressInput.disabled = true;
                    if (searchButton) searchButton.disabled = true;
                }
            }
            
            loadGoogleMapsScript();

            function addLinkToUI(siteName, urlOrError, isError = false, scrapedData = null) {
                const listItem = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'site-name';
                nameSpan.textContent = siteName;
                listItem.appendChild(nameSpan);

                if (isError) {
                    const textSpan = document.createElement('span');
                    textSpan.className = 'no-link';
                    textSpan.classList.add('error-text-small'); 
                    textSpan.textContent = urlOrError;
                    listItem.appendChild(textSpan);
                } else {
                    const link = document.createElement('a');
                    link.href = urlOrError;
                    link.textContent = urlOrError;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.className = 'text-blue-700 hover:underline font-medium'; // Added classes here
                    listItem.appendChild(link);

                    if (scrapedData && Object.keys(scrapedData).length > 0 && !scrapedData.estimatedValues) {
                        const dataDiv = document.createElement('div');
                        dataDiv.className = 'scraped-data';
                        let dataText = ''; // No data text to display here
                        dataDiv.innerHTML = dataText.trim().replace(/\n/g, '<br>');
                        if (dataText.trim()) {
                            listItem.appendChild(dataDiv);
                        }
                    }
                }
                urlList.appendChild(listItem);
            }


            let lowValuesForBolding = [];
            let highValuesForBolding = [];
            let allEstimatedValues = []; // Array to store all estimated values for sorting

            function displayEstimatedValues(siteName, url, estimatedValues, urlError = null) {
                const rowData = { siteName, url, estimatedValues, urlError };
                allEstimatedValues.push(rowData); // Store data to sort later
            }

            function renderEstimatedValuesTable() {
                estimatedValuesTableBody.innerHTML = ''; // Clear existing rows

                // Sort by medium value, highest to lowest
                allEstimatedValues.sort((a, b) => {
                    const mediumA = parseCurrencyToNumber(a.estimatedValues.medium);
                    const mediumB = parseCurrencyToNumber(b.estimatedValues.medium);
                    return mediumB - mediumA; // Descending order
                });

                lowValuesForBolding = []; // Reset for new rendering
                highValuesForBolding = []; // Reset for new rendering

                allEstimatedValues.forEach(rowData => {
                    const { siteName, url, estimatedValues, urlError } = rowData;
                    const row = estimatedValuesTableBody.insertRow();
                    row.className = 'text-sm text-gray-800';

                    const websiteCell = row.insertCell();
                    if (url && url !== 'N/A' && url !== 'No direct link found.' && !url.includes("Error")) {
                        const link = document.createElement('a');
                        link.href = url;
                        link.textContent = siteName;
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.className = 'text-blue-700 hover:underline font-medium';
                        websiteCell.appendChild(link);

                        if (urlError) {
                            const errorSpan = document.createElement('span');
                            errorSpan.classList.add('error-text-small'); 
                            errorSpan.textContent = ` (${urlError})`;
                            websiteCell.appendChild(errorSpan);
                        }

                    } else {
                        websiteCell.textContent = siteName;
                        if (urlError) {
                            const errorSpan = document.createElement('span');
                            errorSpan.classList.add('error-text-small'); 
                            errorSpan.textContent = ` (${urlError})`;
                            websiteCell.appendChild(errorSpan);
                        } else if (url && url.includes("Error")) {
                            const errorSpan = document.createElement('span');
                            errorSpan.classList.add('error-text-small'); 
                            errorSpan.textContent = ` (Error retrieving URL)`;
                            websiteCell.appendChild(errorSpan);
                        }
                    }
                    websiteCell.className += ' py-2 px-4 border-b border-gray-200';

                    const lowCell = row.insertCell();
                    const lowValue = estimatedValues.low || 'N/A';
                    lowCell.textContent = lowValue;
                    lowCell.className = 'py-2 px-4 border-b border-gray-200';
                    const numericLow = parseCurrencyToNumber(lowValue);
                    if (!isNaN(numericLow)) {
                        lowValuesForBolding.push({ value: numericLow, cell: lowCell });
                    }

                    const mediumCell = row.insertCell();
                    mediumCell.textContent = estimatedValues.medium || 'N/A';
                    mediumCell.className = 'py-2 px-4 border-b border-gray-200';
                    // Note: QV.co.nz medium value is already abbreviated, parseCurrencyToNumber handles K/M
                    const numericMediumForHighlight = parseCurrencyToNumber(estimatedValues.medium);
                    if (!isNaN(numericMediumForHighlight)) {
                         // We don't need to add to mediumValues here, as it's for calculation, not highlighting.
                         // But if we wanted to highlight highest medium, we'd add it similarly to low/high.
                    }


                    const highCell = row.insertCell();
                    const highValue = estimatedValues.high || 'N/A';
                    highCell.textContent = highValue;
                    highCell.className = 'py-2 px-4 border-b border-gray-200';
                    const numericHigh = parseCurrencyToNumber(highValue);
                    if (!isNaN(numericHigh)) {
                        highValuesForBolding.push({ value: numericHigh, cell: highCell });
                    }
                });

                highlightMinMaxValues(); // Re-highlight after sorting and rendering
            }

            function highlightMinMaxValues() {
                if (lowValuesForBolding.length > 0) {
                    const minLowValue = Math.min(...lowValuesForBolding.map(item => item.value));
                    lowValuesForBolding.forEach(item => {
                        if (item.value === minLowValue) {
                            item.cell.classList.add('bold-value');
                        }
                    });
                }

                if (highValuesForBolding.length > 0) {
                    const maxHighValue = Math.max(...highValuesForBolding.map(item => item.value));
                    highValuesForBolding.forEach(item => {
                        if (item.value === maxHighValue) {
                            item.cell.classList.add('bold-value');
                        }
                    });
                }
            }


            searchButton.addEventListener('click', async () => {
                const address = addressInput.value.trim();
                urlList.innerHTML = '';
                errorMessage.textContent = '';
                estimatedValuesTableBody.innerHTML = '';
                estimatedValuesSummary.innerHTML = '';
                estimatedValuesSummary.style.display = 'none';
                overallSummaryTextElement.innerHTML = ''; // NEW LINE
                overallSummaryTextElement.style.display = 'none'; // NEW LINE

                summaryDataContainer.style.display = 'none';
                summaryPhotoWrapper.innerHTML = '';
                summaryTextContent.innerHTML = '';
                resultsSection.style.display = 'none';

                introductoryText.style.display = 'none';

                lowValuesForBolding = [];
                highValuesForBolding = [];
                allEstimatedValues = []; // Clear for new search

                if (address === '') {
                    errorMessage.textContent = 'Please enter an address.';
                    return;
                }

                loadingSpinner.style.display = 'block';
                searchButton.disabled = true;

                const apiEndpoints = [
                    { siteName: "RealEstate.co.nz", url: '/api/get-realestate-url', scrapeValuesUrl: '/api/scrape-realestate-values' },
                    { siteName: "OneRoof.co.nz", url: '/api/get-oneroof-url', scrapeValuesUrl: '/api/scrape-oneroof-values' },
                    { siteName: "Homes.co.nz", url: '/api/get-homes-url', scrapeValuesUrl: '/api/scrape-homes-values' },
                    { siteName: "TradeMe.co.nz", url: '/api/get-trademe-url' },
                    { siteName: "QV.co.nz", url: '/api/get-qv-url', scrapeValuesUrl: '/api/scrape-qv-values' }, 
                    { siteName: "PropertyValue.co.nz", url: '/api/get-propertyvalue-url', scrapeValuesUrl: '/api/scrape-propertyvalue-values' }
                ];

                const fetchPromises = apiEndpoints.map(apiInfo =>
                    (async () => {
                        try {
                            const urlResponse = await fetch(apiInfo.url, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ address: address })
                            });

                            if (!urlResponse.ok) {
                                const errorData = await urlResponse.json().catch(() => ({ error: `Failed to parse error from ${apiInfo.siteName} URL API` }));
                                throw new Error(errorData.error || `HTTP error! Status: ${urlResponse.status} from ${apiInfo.siteName} URL API`);
                            }

                            const urlData = await urlResponse.json();
                            let finalUrl = urlData.url;
                            let combinedScrapedData = urlData.data || {};

                            if (apiInfo.scrapeValuesUrl && finalUrl && !finalUrl.includes("No direct link found.")) {
                                try {
                                    const scrapeResponse = await fetch(apiInfo.scrapeValuesUrl, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ url: finalUrl })
                                    });
                                    if (scrapeResponse.ok) {
                                        const scrapeData = await scrapeResponse.json();
                                        combinedScrapedData.estimatedValues = scrapeData.estimatedValues;
                                    } else {
                                        const scrapeErrorData = await scrapeResponse.json().catch(() => ({ error: `Failed to parse scrape error from ${apiInfo.siteName}` }));
                                        console.error(`Failed to scrape ${apiInfo.siteName} values for ${finalUrl}:`, scrapeErrorData.error);
                                        combinedScrapedData.estimatedValues = { low: 'Error', medium: 'Error', high: 'Error' };
                                    }
                                } catch (scrapeError) {
                                    console.error(`Error during ${apiInfo.siteName} value scraping for ${finalUrl}:`, scrapeError);
                                    combinedScrapedData.estimatedValues = { low: 'Error', medium: 'Error', high: 'Error' };
                                }
                            }
                            if (apiInfo.siteName === "PropertyValue.co.nz" && urlData.data) {
                                combinedScrapedData = { ...combinedScrapedData, ...urlData.data };
                            }

                            return { siteName: apiInfo.siteName, result: finalUrl, scrapedData: combinedScrapedData };

                        } catch (error) {
                            return { siteName: apiInfo.siteName, error: error.message };
                        }
                    })()
                );

                try {
                    const results = await Promise.allSettled(fetchPromises);

                    let anyLinkGenerated = false;
                    let pvDataFound = false;
                    let pvDataForCalculation = null;
                    let mediumValues = [];
                    let homesEstimatedValues = null;
                    let pvCapitalValueNumeric = NaN;

                    // NEW SUMMARY TEXT RELATED VARIABLES
                    let sitesWithEstimatesCount = 0;
                    const totalSitesForSummary = apiEndpoints.length; // Will be 6
                    let numericMediumValuesForVariance = [];
                    let broadestRangeSiteName = 'N/A';
                    let broadestRangeValue = 0;

                    results.forEach(promiseResult => {
                        if (promiseResult.status === 'fulfilled') {
                            const { siteName, result, scrapedData } = promiseResult.value;

                            if (siteName === "Homes.co.nz" && scrapedData && scrapedData.estimatedValues) {
                                homesEstimatedValues = scrapedData.estimatedValues;
                            }

                            if (siteName === "TradeMe.co.nz" && homesEstimatedValues) {
                                if (!scrapedData.estimatedValues || Object.values(scrapedData.estimatedValues).every(v => v === 'N/A' || v === 'Error')) {
                                   scrapedData.estimatedValues = { ...homesEstimatedValues };
                                }
                            }
                            
                            if (siteName === "PropertyValue.co.nz" && scrapedData) {
                                let summaryHtml = '';
                                
                                let displayLastSold = scrapedData.lastSold; 
                                const lastSoldPrefix = 'Last Sold on ';
                                if (scrapedData.lastSold && typeof scrapedData.lastSold === 'string' && scrapedData.lastSold.startsWith(lastSoldPrefix)) {
                                    displayLastSold = scrapedData.lastSold.substring(lastSoldPrefix.length);
                                }

                                if (scrapedData.lastSold && scrapedData.lastSold !== 'N/A' && scrapedData.lastSold !== 'Not Found on Page') {
                                    summaryHtml += `<div class="property-value-detail"><strong>Last Sold:</strong> ${displayLastSold}</div>`;
                                } else {
                                     summaryHtml += `<div class="property-value-detail"><strong>Last Sold:</strong> ${displayLastSold || 'N/A'}</div>`;
                                }

                                if (scrapedData.capitalValue && scrapedData.capitalValue !== 'N/A' && scrapedData.capitalValue !== 'Not Found on Page') {
                                    summaryHtml += `<div class="property-value-detail"><strong>Capital Value:</strong> ${scrapedData.capitalValue}</div>`;
                                    pvCapitalValueNumeric = parseCurrencyToNumber(scrapedData.capitalValue);
                                } else {
                                     summaryHtml += `<div class="property-value-detail"><strong>Capital Value:</strong> ${scrapedData.capitalValue || 'N/A'}</div>`;
                                }

                                if (scrapedData.landValue && scrapedData.landValue !== 'N/A' && scrapedData.landValue !== 'Not Found on Page') {
                                    summaryHtml += `<div class="property-value-detail"><strong>Land Value:</strong> ${scrapedData.landValue}</div>`;
                                }
                                if (scrapedData.improvementValue && scrapedData.improvementValue !== 'N/A' && scrapedData.improvementValue !== 'Not Found on Page') {
                                    summaryHtml += `<div class="property-value-detail"><strong>Improvement Value:</strong> ${scrapedData.improvementValue}</div>`;
                                }
                                if (scrapedData.valuationDate && scrapedData.valuationDate !== 'N/A' && scrapedData.valuationDate !== 'Not Found on Page') {
                                    summaryHtml += `<div class="property-value-detail"><strong>Valuation Date:</strong> ${scrapedData.valuationDate}</div>`;
                                }
                                summaryTextContent.innerHTML = summaryHtml;
                                pvDataFound = true;
                                pvDataForCalculation = scrapedData;
                                if (scrapedData.propertyPhotoSrc && scrapedData.propertyPhotoSrc !== 'N/A' && scrapedData.propertyPhotoSrc !== 'Not Found on Page') {
                                    const img = document.createElement('img');
                                    img.src = scrapedData.propertyPhotoSrc;
                                    img.alt = 'Property Photo';
                                    summaryPhotoWrapper.appendChild(img);
                                }
                            }

                            if (result) {
                                addLinkToUI(siteName, result, false, scrapedData);
                                anyLinkGenerated = true;
                            } else {
                                addLinkToUI(siteName, "No direct link found.", true);
                            }

                            if (scrapedData && scrapedData.estimatedValues) {
                                const errorForTable = (result && result.includes("No direct link found.")) ? result : null;
                                displayEstimatedValues(siteName, result, scrapedData.estimatedValues, errorForTable);

                                // Logic for summary text
                                const hasValidEstimate = Object.values(scrapedData.estimatedValues).some(
                                    val => val !== 'N/A' && val !== 'Error' && val !== undefined
                                );
                                if (hasValidEstimate) {
                                    sitesWithEstimatesCount++;
                                }

                                const numericMedium = parseCurrencyToNumber(scrapedData.estimatedValues.medium);
                                if (!isNaN(numericMedium)) {
                                    numericMediumValuesForVariance.push(numericMedium);
                                }

                                const numericLow = parseCurrencyToNumber(scrapedData.estimatedValues.low);
                                const numericHigh = parseCurrencyToNumber(scrapedData.estimatedValues.high);
                                if (!isNaN(numericLow) && !isNaN(numericHigh)) {
                                    const currentRange = numericHigh - numericLow;
                                    if (currentRange > broadestRangeValue) {
                                        broadestRangeValue = currentRange;
                                        broadestRangeSiteName = siteName;
                                    }
                                }

                                if (scrapedData.estimatedValues.medium && scrapedData.estimatedValues.medium !== 'N/A' && scrapedData.estimatedValues.medium !== 'Error') {
                                    const numericValue = parseCurrencyToNumber(scrapedData.estimatedValues.medium);
                                    if (!isNaN(numericValue)) {
                                        mediumValues.push(numericValue);
                                    }
                                }
                            } else {
                                const errorForTable = (result && result.includes("No direct link found.")) ? result : null;
                                displayEstimatedValues(siteName, result, { low: 'N/A', medium: 'N/A', high: 'N/A' }, errorForTable);
                            }

                        } else { 
                            const siteName = promiseResult.reason && promiseResult.reason.siteName ? promiseResult.reason.siteName : 'Unknown Site';
                            const errorMsg = promiseResult.reason && promiseResult.reason.error ? promiseResult.reason.error : "Unknown error occurred.";
                            
                            addLinkToUI(siteName, errorMsg, true);
                            displayEstimatedValues(siteName, null, { low: 'Error', medium: 'Error', high: 'Error' }, errorMsg);
                        }
                    });

                    renderEstimatedValuesTable(); // Call this after allEstimatedValues is populated

                    // GENERATE AND DISPLAY SUMMARY TEXT
                    let summaryParts = [];
                    summaryParts.push(`We found property estimates across <strong>${sitesWithEstimatesCount} of ${totalSitesForSummary} sites</strong>.`);

                    if (numericMediumValuesForVariance.length > 1) {
                        const minMedium = Math.min(...numericMediumValuesForVariance);
                        const maxMedium = Math.max(...numericMediumValuesForVariance);
                        const variance = maxMedium - minMedium;
                        summaryParts.push(`The difference between the highest and lowest medium estimates was <strong>$${variance.toLocaleString('en-NZ', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</strong>.`);
                    } else if (numericMediumValuesForVariance.length === 1) {
                        summaryParts.push(`Only one medium estimate was found, so variance cannot be calculated.`);
                    } else {
                        summaryParts.push(`No valid medium estimates were found to calculate variance.`);
                    }

                    if (broadestRangeValue > 0) {
                        summaryParts.push(`<strong>${broadestRangeSiteName}</strong> has the broadest range between low and high estimate of <strong>$${broadestRangeValue.toLocaleString('en-NZ', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}</strong>.`);
                    } else {
                        summaryParts.push(`No valid low/high ranges were found to determine the broadest range.`);
                    }

                    if (overallSummaryTextElement) {
                        overallSummaryTextElement.innerHTML = summaryParts.join('<br>');
                        overallSummaryTextElement.style.display = 'block';
                    }
                    // END GENERATE AND DISPLAY SUMMARY TEXT

                    if (mediumValues.length > 0) {
                        const totalMedium = mediumValues.reduce((sum, val) => sum + val, 0);
                        const averageMedium = totalMedium / mediumValues.length;

                        let summaryContentHtml = `
                            <div class="flex-1 text-left">
                                <span class="font-bold">Medium Value:</span>
                                <span class="text-lg font-bold text-green-500 ml-2">
                                    $${averageMedium.toLocaleString('en-NZ', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}
                                </span>
                        `;

                        if (!isNaN(pvCapitalValueNumeric)) {
                            const cvDifference = averageMedium - pvCapitalValueNumeric;
                            let differenceText;
                            const formattedDifference = Math.abs(cvDifference).toLocaleString('en-NZ', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                            if (cvDifference > 0) {
                                differenceText = `$${formattedDifference} above CV`;
                            } else if (cvDifference < 0) {
                                differenceText = `$${formattedDifference} below CV`;
                            } else {
                                differenceText = `$0 difference from CV`;
                            }
                            summaryContentHtml += `<span class="text-sm font-normal text-gray-500 block">${differenceText}</span>`;
                        } else {
                            summaryContentHtml += `<span class="text-sm font-normal text-gray-500 block">(Capital Value not available for comparison)</span>`;
                        }
                        summaryContentHtml += `</div>`; 

                        let rateOfReturnHtml = '';
                        // MODIFICATION START: Conditional coloring for annual return
                        let annualReturnColorClass = 'text-green-500'; // Default to green
                        // MODIFICATION END

                        if (pvDataForCalculation && pvDataForCalculation.lastSold && pvDataForCalculation.lastSold !== 'N/A' && pvDataForCalculation.lastSold !== 'Not Found on Page') {
                            const originalLastSoldForParsing = pvDataForCalculation.lastSold;
                            const lastSoldMatch = originalLastSoldForParsing.match(/(\d{4})\s+for\s+\$?([0-9,.]+)/);

                            if (lastSoldMatch && lastSoldMatch.length === 3) {
                                const lastSoldYear = parseInt(lastSoldMatch[1]);
                                const lastSoldPrice = parseCurrencyToNumber(lastSoldMatch[2]);
                                const currentYear = new Date().getFullYear();
                                const numberOfYears = currentYear - lastSoldYear;

                                if (numberOfYears > 0 && lastSoldPrice > 0 && !isNaN(averageMedium) && averageMedium > 0) {
                                    const annualReturn = (Math.pow(averageMedium / lastSoldPrice, 1 / numberOfYears) - 1) * 100;
                                    // MODIFICATION START: Check if annualReturn is negative
                                    if (annualReturn < 0) {
                                        annualReturnColorClass = 'text-red-500'; 
                                    }
                                    // MODIFICATION END
                                    rateOfReturnHtml = `${annualReturn.toFixed(1)}%<span class="text-sm font-normal text-gray-500 block">p.a. since ${lastSoldYear}</span>`;
                                } else {
                                    rateOfReturnHtml = 'N/A<span class="text-sm font-normal text-gray-500 block">Cannot calculate</span>';
                                }
                            } else {
                                rateOfReturnHtml = 'N/A<span class="text-sm font-normal text-gray-500 block">Last sold data malformed</span>';
                            }
                        } else {
                            rateOfReturnHtml = 'N/A<span class="text-sm font-normal text-gray-500 block">Last sold data missing</span>';
                        }

                        summaryContentHtml += `
                            <div class="flex-1 text-right">
                                <span class="font-bold">Annual Return:</span>
                                <span class="text-lg font-bold ${annualReturnColorClass} ml-2">
                                    ${rateOfReturnHtml}
                                </span>
                            </div>
                        `;

                        estimatedValuesSummary.innerHTML = summaryContentHtml;
                        estimatedValuesSummary.style.display = 'flex';
                    }

                    if (pvDataFound) {
                        summaryDataContainer.style.display = 'flex';
                    }

                    if (anyLinkGenerated || mediumValues.length > 0 || pvDataFound) { 
                        resultsSection.style.display = 'block';
                    }

                    if (!anyLinkGenerated && !pvDataFound && mediumValues.length === 0) {
                        errorMessage.textContent = 'No property links, summary data, or estimated values could be generated for the given address from any site.';
                         introductoryText.style.display = 'block'; 
                    }

                } catch (error) {
                    console.error('Overall error during link generation:', error);
                    errorMessage.textContent = error.message || 'An unexpected overall error occurred during link generation.';
                     introductoryText.style.display = 'block'; 
                } finally {
                    loadingSpinner.style.display = 'none';
                    searchButton.disabled = false;
                }
            });
        });
    </script>
</body>
</html>
